# -*- coding: utf-8 -*-
"""preliminarities.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A7828erLqVRfUK0D59q6Tn6uwUIZzSqX
"""

!pip install mxnet gluoncv

"""***2.1 Data Manipulation***"""

# numpy compatible mxnet
from mxnet import np, npx
npx.set_np()

# create a vector ranging from 0 to 12.
x = np.arange(12)
x

# each dimensions shape
x.shape

# total elements
x.size

# reshape the 12 elements without changing them.
X = x.reshape(3, 4)
X

# a tensor of zeroes.
np.zeros((2, 3, 4))

# sample from a gaussian(normal) distribution with a mean of 0 and std of 1.
np.random.normal(0, 1, size=(3, 4))

# elementwise exp of the x matrix.
np.exp(x)

# concatenation of different axes.
X = np.arange(12).reshape(3, 4)
Y = np.array([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
np.concatenate([X, Y], axis=0), np.concatenate([X, Y], axis=1)

# elementwise comparison.
X == Y

# sum over all elements.
X.sum()

# The broadcasting mechanism. (good or bad?)
a = np.arange(3).reshape(3,1)
b = np.arange(2).reshape(1,2)
a, b

# both arrays were extended to match each others sizes..
a + b

# indexing done, as normal with np arrays.
X[-1], X[1:3]

# change a single element
X[1, 2] = 9
X

# changing whole rows.
X[0:2, :] = 12
X

# a new memory space is allocated each time.
before = id(Y)
Y = Y + X
id(Y) == before

# wont happen if done this way.
before = id(Y)
Y += X
id(Y) == before

# [:] also shows in place expressions, not deferencing the variable.

Z = np.zeros_like(Y)
print('id(Z):', id(Z))
Z[:] = X + Y
print('id(Z):', id(Z))

# type conversion to numpy.

A = X.asnumpy()
B = np.array(A)
type(A), type(B)

# convert to python types

a = np.array([3.5])
a, a.item(), float(a), int(a)

"""***2.2 Data Preprocessing***"""

# utility function to create directories in the wanted address.
import os 
def mkdir_if_not_exist(path):
  """Make a directory if it does not exist."""
  # check if the path is a string.
  if not isinstance(path, str):
    path = os.path.join(*path)
  if not os.path.exists(path):
    os.makedirs(path)

# create a dataset.
data_file='../data/house_tiny.csv'
mkdir_if_not_exist('../data')
with open(data_file, 'w') as f:
  f.write('NumRooms,Alley,Price\n') # Column names
  f.write('NA,Pave,127500\n') # Each row represents a data example
  f.write('2,NA,106000\n')
  f.write('4,NA,178100\n')
  f.write('NA,NA,140000\n')

import pandas as pd
data = pd.read_csv(data_file)
print(data)

# fill in the NaN values,
# hint that the categorical variables dont need to be filled.
inputs, outputs = data.iloc[:, 0:2], data.iloc[:, 2]
inputs = inputs.fillna(inputs.mean())
print(inputs)

# create two seperate features for alley=pave and alley=nan
inputs = pd.get_dummies(inputs, dummy_na=True)
print(inputs)

# convert to numpy for further training, or tf.constant & torch.tensor in other frameworks.
from mxnet import np

X, y = np.array(inputs.values), np.array(outputs.values)
X, y

"""***2.3 Linear Algebra***"""

# ∈: means element of, like pythons 'in' statement.
# ⊂: means subset of. 

# scalar operations.
from mxnet import np, npx
npx.set_np()

x = np.array(3.0)
y = np.array(2.0)

x + y, x * y, x / y, x ** y

# vector
x = np.arange(4)
x

# matrix
A = np.arange(20).reshape(5, 4)
A

# matrix transpose, (replacing rows and columns)
A.T

# Special case: symmetric matrix, where the matrix and the transpose are equal.

B = np.array([[1, 2, 3], [2, 0, 4], [3, 4, 5]])
B

# pay attention to the diagonal.
B == B.T

X = np.arange(24).reshape(2, 3, 4)
X

# reduction
x = np.arange(4)
x, x.sum()

A_sum_axis0 = A.sum(axis=0)
A_sum_axis0, A_sum_axis0.shape

A.sum(axis=[0, 1]) == A.sum()  # Same as `A.sum()`

# obvious.
A.mean(axis=0), A.sum(axis=0) / A.shape[0]

sum_A = A.sum(axis=1, keepdims=True)

# culmucative sum.
A.cumsum(axis=0)

y = np.ones(4)
x, y, np.dot(x, y)

np.sum(x * y)

# matrix multiplication
B = np.ones(shape=(4, 3))
np.dot(A, B)

# norms
# l2 norm sqrt(sum(x**2))

u = np.array([3, -4])
np.linalg.norm(u)

# l1 norm
# less senserive to outliers.

np.abs(u).sum()

# fobenius norm (similar to that of the l2 norm for matrices).
np.linalg.norm(np.ones((4, 9)))

np.abs(np.ones((4, 9))).sum()